# Overall Response

We would like to express our sincere gratitude for the constructive feedback received from the reviewer. 
We will carefully address the points raised and implement the necessary changes to our paper.

First, we address the efficiency of our lazy normalization approach. 
The classical algorithm always performs a full traversal of the coalgebra during liveness checking prior to bisimulation checking, our algorithm invokes bisimulation and only run traverses the reachable states of the discrepancy state.
Therefore, our algorithm consistently traverses fewer states for liveness checking, even for positive results. 
Additionally, lazy liveness checking enables on-the-fly coalgebra generation using methods like derivatives, which the original algorithm does not support.

Second, we address the theoretical contribution of our work. 
While the result may seem intuitive, we maintain that our proof is not trivial. 
In particular, directly connecting the algorithm with bisimulation on the normalized coalgebra will be challenging (similar to Theorem 20), since we assume neither the input coalgebra nor their bisimulation is finite.
We have reworked the framework several times to pin-down the intuitive and concise coalgebra structure "greedy bisimulation" to sever as a middle ground, so that most of the proof are either unfolding definitions or results of standard coalgebra manipulations.

Finally, we emphasize that our contribution extends beyond bisimulation of machines (or coalgebras).
In Section V, we present two methods for generating coalgebras from expressions and prove their correctness, finiteness, and correspondence.
The finiteness result, in particular, arises naturally from the correspondence result. 
The simplicity of this result is noted by one of the reviewers.

Regarding experiments in our work, we have updated our test cases with all the "trivial" or dead test cases removed, this development can be found in our repository: https://anonymous.4open.science/r/rust-gkat-071E/ .
Evidently, our performance are minimally impacted by the new test cases. 
We hypothesize that because our implementation is so fast, non-negligible amount of time are spent on parsing and hash-consing expressions.
Plus, trivial test cases do not provide any performance benefit for our algorithm based on Thompson's construction, and dead test cases also do not favor our algorithm against other tools. 

# Reviewer Questions

### Reviewer 1

> Where are the benchmarks from?

It is generated by https://github.com/c-cube/qcheck, based on congruence, symmetry, and some algebraic rules of GKAT (excluding rules that will be "trivial" tests, as named by Reviewer 3).
We will include the generation script in the final submission, and provide documentation on test generation

> Unnecessary but harmful generalization

We will specify in the background section that we assume the function `F` to be simple polynomial functors.

### Reviewer 2

Our approach to symbolic transducers diverges from previous works in several key aspects:
- Our on-the-fly method is tailored to handle normalization, a unique challenge in achieving finite trace equivalence for GKAT. 
- The signature of GKAT differs from traditional symbolic transducers. Unlike typical accepting or rejecting states, a GKAT state can accept or reject based on different input atoms. This results in a distinct semantics where a trace's end is marked by an atom, representing the output program state.

While symbolic bisimulation is pivotal for the efficiency of our equivalence algorithm, it is not our sole theoretical contribution. 
We have also developed:
- An on-the-fly algorithm for bisimulation, and proved its correctness using greedy bisimulation, a novel coalgebra construction.
- Two distinct methods to construct symbolic GKAT coalgebras, while also proved their correctness, finiteness, and correspondence. 

# Detailed Response

### Reviewer 1

> why is it relevant to check whether two GKAT expressions are equivalent?

GKAT has been used in several important verification tasks in the domain of networks, control-flow transformation, probabilistic computation, and program logic.
We mentioned this fact at the end of the related work section. 
We will also mention the practical application of GKAT in the introduction section.

> it's unclear to me what section III is for if you have section IV

The correctness result of section IV is based on the correctness result in section III. 
Besides, there can be edge cases (depending on the application) where the number of primitive tests are so small that the algorithm in section III can potentially be more efficient. 

### Reviewer 2

> there can still be dead states in a normalized coalgebra

As in all the works in GKAT, dead states are indeed preserved in the normalized coalgebra.
This approach makes the normalized coalgebra share the carrier as the original coalgebra, allowing the semantics of states to be defined via the unique map into final coalgebra, as it is standard.

> can you say a bit more about SymKAT and why it might perform worse

SymKAT is a symbolic equivalence checker for Kleene Algebra with Tests (KAT).
Our algorithm is specialized to GKAT, thus able to leverage the deterministic structure to produce smaller automata (coalgebra) and use existing SAT solver to resolve boolean equivalence/inequivalence.
Our work is both the first theoretical and practical demonstration that GKAT equivalence can be checked more efficiently than KAT, by using a specialized solver like we designed in this paper.

> GKAT is a bit artificial

GKAT semantics corresponds to trace semantics, a standard semantics of programming language and control-flow analysis.
Indeed, as you specified, trace equivalence is a stronger equivalence than input-output equivalence.
However, trace equivalence turns out to be useful in various applications, as we listed in the last paragraph of the related works section, and in response to reviewer 1.

### Reviewer 3

> Theorem 23 is true, but Theorem 23 is not the proper tool to justify the correctness of the algorithm as mentioned on p7c2

A union-find structure represents an equivalence relation. 
By employing union-find instead of a set of state pairs, our algorithm will effectively search for a greedy bisimulation that is also an equivalence relation. 
While the correctness of greedy bisimulation is established (Theorem 21), there is no inherent justification for why finding a greedy bisimulation that is also an equivalence relation is equivalent to finding just any greedy bisimulation. 
To address this, we will apply Theorem 23 to demonstrate that there exists a greedy bisimulation that is also an equivalence relation if and only if two states are trace equivalent.

> p5c2 "This approach offers several benefits: first, the liveness detection is only called when necessary, thus unlikely to iterate through the entire coalgebra; second, the algorithm can short-circuit on a counter-example, finally [...]""
> -> The first two are the same benefit.

The first benefit stems from the laziness of our liveness checking algorithm, allowing us to iterate through fewer states in the classical algorithm (see overall response and the next comment).  
This benefit is apparent no matter the result or the generation method of the coalgebra. 
The second benefit stems from the on-the-fly nature of our algorithm.
Specifically, our algorithm can terminate without generating the rest of the coalgebra, when a counter-example is encountered while applying an on-the-fly generation method (such as derivatives).
In contrast, the original algorithm requires the complete generation of the coalgebra in order to perform liveness checking first.

> p7c2 "In the extreme case when the two input states are infinite-trace equivalent, the on-the-fly algorithm can even skip liveness checking entirely." 
> -> yes, but in that case the liveness analysis would be faster (linear instead of almost linear)

We are uncertain why the original algorithm might be faster in this specific case. 
The original algorithm requires determining the liveness of every single state before performing bisimulation. 
In contrast, our algorithm only conducts liveness checking on a few states when the bisimulation algorithm detects a discrepancy.
Consider two bisimilar states (not just finite-trace equivalent) in a GKAT coalgebra composed entirely of live states. 
The classical algorithm would first perform a liveness check, iterating through all the states, and then proceed with bisimulation, iterating through all the states again. 
Our algorithm, however, simply performs the bisimulation and confirms there is no discrepancy, effectively bypassing the liveness check altogether.


> say somewhere that these are more Antimorov' partial derivatives than Brzozowski's derivatives

Although we do have power set in the signature of symbolic GKAT coalgebra, our derivative do not transition in a non-deterministic manner.
In fact, we are able to out-perform state-of-the-art tools for KAT equivalence precisely because the GKAT fragment is deterministic.
We believe that our derivative is closer to Brozozowski style derivative, as we will transition to (at most) a single expression given an input expression, as opposed to a set of expression.







