# Overall Response

We would like to express our sincere gratitude for the constructive feedback received from the reviewer. We will carefully address the points raised and implement the necessary changes to our paper.

First, we address the efficiency of our lazy normalization approach. 
The classical algorithm guarantees a full traversal of the coalgebra during liveness checking prior to bisimulation checking, our algorithm invokes bisimulation and only run traverses the reachable states of the discrepancy state.
Therefore, our lazy liveness checking consistently traverses fewer states, even for positive results. 
Additionally, lazy liveness checking enables on-the-fly coalgebra generation using methods like derivatives, which the original algorithm does not support.

Second, we address the theoretical contribution of our work. 
While the result may seem practically intuitive, we maintain that our proof is not trivial. 
We are able to provide straightforward and concise proofs because we introduced a middle ground between coalgebraic theory and practical algorithm, namely greedy bisimulation. 
Without this framework, verifying Theorem 22 and Theorem 23 would be more challenging, especially given that neither the input coalgebra nor their greedy bisimulation are assumed to be finite. 

Finally, we emphasize that our contribution extends beyond bisimulation of machines (or coalgebras).
In Section V, we present two methods for generating coalgebras from expressions and prove their correctness, finiteness, and correspondence.
The finiteness result, in particular, arises naturally from the correspondence result. 
The simplicity of this result is noted by one of the reviewers.

Regarding the practical aspects of our work, specifically the experiments, we are committed to revising the tests to better represent real-world scenarios before the deadline. 
However, we also argue that our theoretical results have already demonstrated improvements over existing methods. 
Plus, trivial test cases do not provide any performance benefit for our algorithm based on Thompson's construction, and dead test cases also do not favor our algorithm against other tools. 
Although we will improve the balance and coverage of our test cases, we believe the current test cases are sufficient in demonstrating the efficiency of our implementation.

# Reviewer Questions

### Reviewer 1

> Where are the benchmarks from?

The benchmark is generated by qcheck library of Ocaml, using the module QCheck2. 
The generation is based on algebraic rules of GKAT (except the fixpoint rules) with reflexivity and symmetry rule.
We will include the generation script in the final submission, and provide documentation on test generation

> Unnecessary but harmful generalization

We will specify in the background section that we assume the function `F` to be simple polynomial functors.

### Reviewer 2

Our approach to symbolic transducers diverges from previous works in several key aspects:
- Our on-the-fly method is tailored to handle normalization, a unique challenge in achieving finite trace equivalence for GKAT. 
- The signature of GKAT differs from traditional symbolic transducers. Unlike typical accepting or rejecting states, a GKAT state can accept or reject based on different input atoms. This results in a distinct semantics where a trace's end is marked by an atom, representing the output program state.

While symbolic bisimulation is pivotal for the efficiency of our equivalence algorithm, it is not our sole theoretical contribution. 
We have also developed:
- An on-the-fly algorithm for bisimulation, and proved its correctness using greedy bisimulation, a novel coalgebra construction.
- Two distinct methods to construct symbolic GKAT coalgebras, while also proved their correctness, finiteness, and correspondence. 

# Detailed Response

### Reviewer 1

> why is it relevant to check whether two GKAT expressions are equivalent?

GKAT has been used in several important verification tasks in the domain of networks, control-flow transformation, probabilistic computation, and program logic.
We mentioned this fact at the end of the related work section. 
We will also mention the practical application of GKAT in the introduction section.

> it's unclear to me what section III is for if you have section IV

The correctness result of section IV is based on the correctness result in section III. 
Besides, there are also cases where the number of primitive tests are small and the algorithm in section III can potentially be more efficient. 

### Reviewer 2

> there can still be dead states in a normalized coalgebra

Dead states are indeed preserved in the normalized coalgebra.
This approach makes the normalized coalgebra share the same carrier as the original coalgebra, allowing us to define the semantics of dead states also via the unique map into final coalgebra.

> can you say a bit more about SymKAT and why it might perform worse

SymKAT is a symbolic equivalence checker for Kleene Algebra with Tests (KAT).
Our algorithm is specialized to GKAT, thus able to leverage the deterministic structure to produce smaller automata (coalgebra) and use existing SAT solver to resolve boolean equivalence/inequivalence.
Our contribution, to the best of our knowledge, is both a theoretical and practical demonstration that GKAT equivalence can be checked more efficiently using a specialized solver.

### Reviewer 3

> Theorem 23 is true, but Theorem 23 is not the proper tool to justify the correctness of the algorithm as mentioned on p7c2

A union-find structure represents an equivalence relation. 
By employing union-find instead of a set of equivalent pairs, the algorithm will search for a greedy bisimulation that is also an equivalence relation. 
While the correctness of greedy bisimulation is established (Theorem 21), there is no inherent justification for why finding a greedy bisimulation that is also an equivalence relation is equivalent to finding just any greedy bisimulation. 
To address this, we will apply Theorem 23 to demonstrate that there exists a greedy bisimulation that is also an equivalence relation if and only if two states are trace equivalent.

> p5c2 "This approach offers several benefits: first, the liveness detection is only called when necessary, thus unlikely to iterate through the entire coalgebra; second, the algorithm can short-circuit on a counter-example, finally [...]""
> -> The first two are the same benefit.

The first benefit stems from the laziness of our liveness checking algorithm, allowing us to iterate through fewer states in the classical algorithm (see overall response and the next comment).  
This benefit is apparent no matter the result or the generation method of the coalgebra. 
The second benefit stems from the on-the-fly nature of our algorithm.
Specifically, our algorithm can terminate without generating the rest of the coalgebra, when a counter-example is encountered while applying an on-the-fly generation method (such as derivatives).
In contrast, the original algorithm requires the complete generation of the coalgebra in order to perform liveness checking first.

> p7c2 "In the extreme case when the two input states are infinite-trace equivalent, the on-the-fly algorithm can even skip liveness checking entirely." 
> -> yes, but in that case the liveness analysis would be faster (linear instead of almost linear)

We are uncertain why the original algorithm might be faster in this specific case. 
The original algorithm requires determining the liveness of every single state before performing bisimulation. 
In contrast, our algorithm only conducts liveness checking on a few states when the bisimulation algorithm detects a discrepancy.
Consider two bisimilar states (not just finite-trace equivalent) in a GKAT coalgebra composed entirely of live states. 
The classical algorithm would first perform a liveness check, iterating through all the states, and then proceed with bisimulation, iterating through all the states again. 
Our algorithm, however, simply performs the bisimulation and confirms there is no discrepancy, effectively bypassing the liveness check altogether.









<!-- 
!!!!!!! NOTES, DO NOT SUBMIT !!!!!!!
1. Practicality of the tool
    - Speed up of normalization 
        - discussion at the end of section III;
        - better sketch of liveness checking.
    - Trivial/Dead Equivalence
2. Comparison with existing work
    - Intuitive, but coalgebraic characterization is novel
    - coalgebraic characterization enables straightforward proofs
    - Theorem 22 is non-trivial because there is no assumption of finiteness
3. additional results besides automata
    - We also presented two ways to generate automata in Section V and proved them correct and equivalent.
    - Automata shape difference, allow acceptation or rejection based on an atom.
3. Tests generation
    - We generate the tests roughly based on the shape of real-world program input 
        - more sequencing than while etc.
    - negative cases are random expression, but they still need to do liveness check
    - We will rework the tests to 
        - reduce the number of trivial and dead tests, 
        - make sure that the random expression do go into dead state detection immediately
4. Writing
    - More about the efficiency of laziness 
-->

