% Please compile this document using LuaLaTeX.
% XeLaTeX and PDFLaTeX will not work.

\newif\iffull\fulltrue
\newif\ifacm\acmfalse

%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\ifacm
    \documentclass[acmsmall,screen]{acmart}
    %% For double-blind review submission, w/ CCS and ACM Reference
    %\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
    %% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
    %\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
    %% For single-blind review submission, w/ CCS and ACM Reference
    %\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
    %% For final camera-ready submission, w/ required CCS and ACM Reference
    %\documentclass[acmsmall]{acmart}\settopmatter{}
\else
    \documentclass{extarticle}
\fi

\ifacm
    %%% If you see 'ACMUNKNOWN' in the 'setcopyright' statement below,
    %%% please first submit your publishing-rights agreement with ACM (follow link on submission page).
    %%% Then please update our instructions page and copy-and-paste the NEW commands into your article.
    %%% Please contact us in case of questions; allow up to 10 min for the system to propagate the information.
    %%%
    %%% The following is specific to POPL '22 and the paper
    %%% 'On Incorrectness Logic and Kleene Algebra with Top and Tests'
    %%% by Cheng Zhang, Arthur Azevedo de Amorim, and Marco Gaboardi.
    %%%
    \acmPrice{}
    \acmDOI{10.1145/3498690}
    \acmYear{2022}
    \copyrightyear{2022}
    \acmSubmissionID{popl22main-p160-p}
    \acmJournal{PACMPL}
    \acmVolume{6}
    \acmNumber{POPL}
    \acmArticle{29}
    \acmMonth{1}
    \startPage{1}

    %% Copyright information
    %% Supplied to authors (based on authors' rights management selection;
    %% see authors.acm.org) by publisher for camera-ready submission;
    %% use 'none' for review submission.
    \setcopyright{rightsretained}
    %\setcopyright{acmcopyright}
    %\setcopyright{acmlicensed}
    %\setcopyright{rightsretained}
    %\copyrightyear{2018}           %% If different from \acmYear

    %% Bibliography style
    \bibliographystyle{ACM-Reference-Format}
    %% Citation style
    %% Note: author/year citations are required for papers published as an
    %% issue of PACMPL.
    \citestyle{acmauthoryear}   %% For author/year citations

\else 

    %% Bibliography style
    \bibliographystyle{plainnat}

\fi



%%%%% PACKAGES

\ifacm 
\else 
    \usepackage{amsmath}
    \usepackage{amssymb}
    \usepackage{amsthm}
    \usepackage[numbers]{natbib}
    \usepackage[margin=3cm]{geometry}
\fi

% For adding inline comments in the text.
\usepackage[margin=false,inline=true]{fixme}
\FXRegisterAuthor{aaa}{anaaa}{\color{cyan}AAA}
\FXRegisterAuthor{mg}{anmg}{\color{red}MG}
\FXRegisterAuthor{cz}{ancz}{\color{orange}CZ}
% \newcommand{\aaa}[1]{\aaanote{#1}}
% \newcommand{\mg}[1]{\mgnote{#1}}
% \newcommand{\cz}[1]{\cznote{#1}}
\newcommand{\aaa}[1]{}
\newcommand{\mg}[1]{}
\newcommand{\cz}[1]{}

\usepackage{stmaryrd}

\usepackage{stackengine}
\usepackage{mathrsfs}
\usepackage{braket}
\usepackage{annotate-equations}
\usepackage{scalerel}

% graphs
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}

% commutative diagram
\usepackage{tikz-cd}

% inference rule
\usepackage{mathpartir}

% ref
\usepackage{hyperref}
\usepackage{cleveref}

% item spacing
\usepackage{enumitem}

% for code
\usepackage{listings}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,frame=bottomline}
\lstset{language=caml, escapeinside={[*}{*]}}

% for better table
\usepackage{booktabs}

% subcaption
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

% unicode math symbols
\usepackage{unicode-math}
% support for hat, overline, underline, vec, and sim combining charactors
\protected\def\afteracc{\directlua{
    local nest = tex.nest[tex.nest.ptr]
    local last = nest.tail
    if not (last and last.id == 18) then
      error'I can only put accents on simple noads.'
    end
    if last.sub or last.sup then
      error'If you want accents on a superscript or subscript, please use braces.'
    end
    local acc = node.new(21, 1)
    acc.nucleus = last.nucleus
    last.nucleus = nil
    local is_bottom = token.scan_keyword'bot' and 'bot_accent' or 'accent'
    acc[is_bottom] = node.new(23)
    acc[is_bottom].fam, acc[is_bottom].char = 0, token.scan_int()
    nest.head = node.insert_after(node.remove(nest.head, last), nil, acc)
    nest.tail = acc
    node.flush_node(last)
  }}
\AtBeginDocument{
\begingroup
  \def\UnicodeMathSymbol#1#2#3#4{%
    \ifx#3\mathaccent
      \def\mytmpmacro{\afteracc#1 }%
      \global\letcharcode#1=\mytmpmacro
      \global\mathcode#1="8000
    \else\ifx#3\mathbotaccentwide
      \def\mytmpmacro{\afteracc bot#1 }%
      \global\letcharcode#1=\mytmpmacro
      \global\mathcode#1="8000
    \fi\fi
  }
  \input{unicode-math-table}
\endgroup
}

% math font, this is needed to render \setminus command
\setmathfont{latinmodern-math}
\setmathfont[range=\setminus]{STIX Two Math}
\setmathfont[range=\similarrightarrow]{STIX Two Math}

% move proof to the end
\iffull
    \usepackage[conf={restate}]{proof-at-the-end}
\else
    \usepackage[conf={restate, no link to proof}]{proof-at-the-end}
\fi
% enable the following to debug proofs
% \renewenvironment{proofEnd}{%
%     \begin{proof}%
% }{%
%     \end{proof}%
% }

\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newtheorem{definition}{Definition}
\newtheorem*{definition*}{Definition}
\newtheorem{example}{Example}
\newtheorem{remark}{Remark}

%%%% Macros %%%%%

% Math?
\newcommand{\true}{\mathrm{true}}
\newcommand{\false}{\mathrm{false}}
\newcommand{\At}{\mathbf{At}}


% operators
\newcommand{\dom}[1]{\mathrm{dom}(#1)}
\newcommand{\cod}[1]{\mathrm{cod}(#1)}
\DeclareMathOperator{\post}{\mathrm{post}}
\DeclareMathOperator{\Img}{\mathrm{\mathbf{Img}}}
\newcommand{\reject}{\mathinner{\mathtt{Reject}}}
\newcommand{\accept}{\mathinner{\mathtt{Accept}}}
\DeclareMathOperator*{\bigplus}{\scalerel*{+}{\sum}}
\newcommand{\closSim}{\mathrel{\overline{\sim}}}
\DeclareMathOperator{\norm}{\mathrm{norm}}


% commands 
\newcommand{\command}[1]{{\mathtt{#1}}}
\newcommand{\comSkip}{\command{skip}}
\newcommand{\comDiverge}{\command{diverge}}
\newcommand{\comFork}{\command{fork}}
\newcommand{\comJoin}{\command{join}}
\newcommand{\comError}{\command{error ()}}
\newcommand{\comAssume}[1]{\command{assume}~#1}
\newcommand{\comITE}[3]{\command{if}~#1~\command{then}~#2~\command{else}~#3}
\newcommand{\comWhile}[2]{\command{while}~#1~\command{do}~#2}
\newcommand{\comAssign}[2]{#1:= #2}
\newcommand{\comLoop}[1]{\command{loop}~#1}
\newcommand{\comIter}[1]{{#1}^{\star}}
\newcommand{\comBreakN}[1]{\command{break} ~ #1}
\newcommand{\comBreak}{\command{break}}


% set of models
\newcommand{\theoryOf}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\KA}{\theoryOf{KA}}
\newcommand{\KAT}{\theoryOf{KAT}}
\newcommand{\GKAT}{\theoryOf{GKAT}}
\newcommand{\BExp}{\theoryOf{BExp}}
\DeclareMathOperator{\GS}{\mathrm{GS}}

\newcommand\altxrightarrow[2][0pt]{\mathrel{\ensurestackMath{\stackengine%
  {\dimexpr#1-7.5pt}{\xrightarrow{\phantom{#2}}}{\scriptstyle\!#2\,}%
  {O}{c}{F}{F}{S}}}}

\newcommand{\transvia}[1]{
    \mathrel{\raisebox{-2px}{\(\altxrightarrow[-2px]{#1}\)}}
}

 

\begin{document}

%% Title information
\title{A Symbolic Decision Procedure for GKAT}         
% \title{Incorrectness Logic and Kleene Algebra With Top and Test}         
                                        %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{}                            %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%% \subtitle is optional                     
 
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                         %% can be repeated if necessary;
%                                         %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.
\ifacm
    \author{Cheng Zhang}
    \orcid{0000-0002-8197-6181}            
    \email{czhang03@bu.edu}          

    % \author{Arthur Azevedo de Amorim}
    % \orcid{}
    % \email{arthur.aa@gmail.com}

    % \author{Marco Gaboardi}
    % \orcid{}
    % \email{gaboardi@bu.edu}

    \affiliation{
    % \position{Position1}
    \department{Department of Computer Science}              %% \department is recommended
    \institution{Boston University}            %% \institution is required
    \city{Boston}
    \state{MA}
    \postcode{02215}
    \country{USA}                    %% \country is recommended
    }
\else
    \author{
    }
    \date{}
\fi

\ifacm 
\else 
    % In non-ACM format \maketitle needs to happen before abstract
    \maketitle
\fi 


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
\end{abstract}

\ifacm 
%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10003752.10010124.10010138.10010140</concept_id>
        <concept_desc>Theory of computation~Program specifications</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10010124.10010138.10010141</concept_id>
        <concept_desc>Theory of computation~Pre- and post-conditions</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10010124.10010138.10011119</concept_id>
        <concept_desc>Theory of computation~Abstraction</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Program specifications}
\ccsdesc[500]{Theory of computation~Pre- and post-conditions}
\ccsdesc[500]{Theory of computation~Abstraction}

%% Keywords
%% comma separated list
\keywords{Program Reasoning,
  Incorrectness Logic, 
  Hoare Logic,
Kleene Algebra with Tests,
}  %% \keywords are mandatory in final camera-ready submission

\fi


\ifacm 
%% \maketitle
%% Note: in ACM format \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle
\fi

\section{Symbolic Derivatives}

Given a finite set \(K\), a \emph{symbolic Deterministic Kleene Coalgebra with Tests} (sDKCT) \(𝒮 ≜ ⟨S, ϵ, δ⟩\) over a boolean algebra \(ℬ\) consists of a state set \(S\) consists of a accepting boolean \(ϵ\) and a transition function \(δ\):
\begin{mathpar}
    ϵ: S → ℬ, \and
    δ: S → S → K → ℬ,
\end{mathpar}
where for all states \(s ∈ S\), all the booleans are ``disjoint''; namely the conjunction of any two expression from the set \(ϵ(s) + \{δ(s, s', p) ∣ s' ∈ S, p ∈ K\}\) are false.
The ordering on \(𝒮\) is defined pointwise, namely 
\[⟨ϵ₁, δ₁⟩ ≤ ⟨ϵ₂, δ₂⟩ \text{ when } ∀ s, s' ∈ S, ∀ p ∈ K, ϵ₁(s) ≤ ϵ₂(s) \text{ and } δ₁(s, s', p) ≤ δ₂(s, s', p),\]
where the ordering on the right hand side is defined in the boolean algebra.

Intuitively, the elements of boolean is treated as the ``symbolic'' transitions, which can be think of as a set of labels by the classical stone's representation theorem. 
In particular, when the boolean algebra is the free boolean algebra \(\BExp_B\) generated by a finite set \(B\), the labels can be considered as atoms, since \(\BExp_B ≅ 2^{\At_B}\). 
Then we can explain the intuition for the definition of DKCT
\begin{itemize}
    \item \(ϵ(s)\) can be thought of as a set of labels that is accepted by the state \(s\).
    \item \(δ(s, s', p)\) denotes all the labels that can transition from \(s\) to \(s'\) while executing \(p\).
\end{itemize}
Then the labels that is not in either operations are implicitly rejecting.

Given a sDKCT \(𝒮 ≜ ⟨S, ϵ, δ⟩\) and a state \(s ∈ S\), we use the notation \(s ⇒ b\) to denote that \(ϵ(s) ≥ b\), and we use the notation \(s \transvia{b ∣ p} s'\) to denote that \(δ(s)₃(s', p) ≥ b\), where the ordering is the typical ordering in boolean algebra.

The symbolic derivatives for GKAT forms a DKCT where the states are represented by GKAT expression \(\GKAT_{K, B}\), and the boolean algebra is the free boolean algebra \(\BExp_B\) over the test alphabet \(B\):
\begin{mathpar}
    ϵ: \GKAT_{K, B} → \BExp_B; \and  
    δ: \GKAT_{K, B} → \GKAT_{K, B} → K → \BExp_B.
\end{mathpar} 
the accepting map \(ϵ\) and transition map \(δ\) can be defined by the smallest maps that satisfy the following rules:
\begin{mathpar}
    \inferrule{\\}{b ⇒ b} \and 
    \inferrule{\\}{p \transvia{1 ∣ p} 1} \and 
    \inferrule{e ⇒ a}{e +_b f ⇒ b a} \and 
    \inferrule{f ⇒ a}{e +_b f ⇒ b̄ a} \and 
    \inferrule{e \transvia{a ∣ p} e'}{e +_b f \transvia{b ∧ a ∣ p} e'} \and 
    \inferrule{f \transvia{a ∣ p} f'}{e +_b f \transvia{b̄ ∧ a ∣ p} f'} \and 
    \inferrule{e ⇒ a \\ f ⇒ b}{e ⋅ f ⇒ a ∧ b} \and 
    \inferrule{e ⇒ a \\ f \transvia{b ∣ p} f'}{e ⋅ f \transvia{a ∧ b ∣ p} f'} \and 
    \inferrule{e \transvia{b ∣ p} e'}{e ⋅ f \transvia{b ∣ p} e' ⋅ f} \and 
    \inferrule{\\}{e^{(b)} ⇒ b̄} \and 
    \inferrule{e \transvia{a ∣ p} e'}{e^{(b)} \transvia{b ∧ a ∣ p} e' ⋅ {e}^{(b)}}
\end{mathpar}


\section{Implementing derivatives}

Since the rules listed above is monotonic, that is if we enlarge the boolean in the premise, we also enlarge the boolean in the result. 
So we can simply pick the largest boolean on the premise, which is either \(ϵ(e)\) or \(δ(e, e', p)\).
Since the disjunction of two boolean \(a ∨ b\) is the smallest boolean that is greater than both \(a\) and \(b\), thus we can implement \(ϵ\) and \(δ\) by iteration through all the rules, and take the disjunction of all the possible booleans.

\begin{align*}
    ϵ(b) & ≜ b 
        &  ϵ(e +_b f) & ≜ (b ∧ ϵ(e)) ∨ (b̄ ∧ ϵ(f))\\
    ϵ(q) & ≜ 0
        & ϵ(e ⋅ f) & ≜ ϵ(e) ∧ ϵ(f)\\  
    ϵ(e^{(b)}) & ≜ b̄ 
\end{align*}

However, the derivative function \[δ: \GKAT_{K, B} → \GKAT_{K, B} → K → \BExp_B,\] poses challenges in the implementation, since \(\GKAT_{K, B}\) is infinite, so it will be impractical to search through all the expressions.
However, we can treat the function \(δ\) extensionally: \[\GKAT_{K, B} → K → \BExp_B ⊆ 2^{\GKAT_{K, B} × K × \BExp_B},\]
and then because the boolean expression don't overlap for each input, hence the boolean expression are necessarily unequal; 
we can model the set by a partial map, thus all the \(δ\) can be represented as a function to the following partial maps.
\begin{align*}
    δ & : \GKAT_{K, B} → (\BExp_B ↛ \GKAT_{K, B} × K) \\
    δ(b) & ≜ \{\} \\
    δ(q) & ≜ \{1 ↦ (1, p)\}\\  
    δ(e +_b f) & ≜ \{b ∧ a ↦ (e', p) ∣ a ↦ (e', p) ∈ δ(e)\} 
        ∪ \{b̄ ∧ a ↦ (f', p) ∣ a ↦ (f', p) ∈ δ(f)\}\\
    δ(e ⋅ f) & ≜ \{b ↦ (e' ⋅ f, p) ∣ b ↦ (e, p) ∈ δ(e)\}
        ∪ \{ϵ(e) ∧ b ↦ (f', p) ∣ b ↦ (f', p) ∈ δ(f)\}\\
    δ(e^{(b)}) & ≜ \{b ∧ a ↦ (e' ⋅ e^{(b)}, p) ∣ a ↦ (e', p) ∈ δ(e)\}.
\end{align*}
FIXME: we still need to think about what representation do we want to go with, with this representation, you can also have duplicated K. We need a good example here of why don't we go with map. One good argument is that this representation is complex.




% \section{On the Fly Normalization}

% Normalization of a GKAT automaton will remove all the dead state, which are states that cannot lead to an accepting transitions. 
% However, this process is hard to do on-the-fly, mainly because of the difficulty of handling infinite loops.
% \begin{example}
%     We can consider a simple extension to a BFS algorithm, where we will mark a state as either live, dead, or searching. 
%     A state is marked as ``searching'' when it has been explored but not yet known to be dead or alive yet,
%     and when a state loops back to a searching state, then we can declare the detection of a infinite loop, hence marking the transition dead.
%     We consider the following coalgebra over a two element set \(\{1, 2\}\):
%     \[
%     \begin{tikzcd}[row sep=15px]
%         1 \ar[bend right, swap]{r}{b ∣ p} \ar[Rightarrow, swap]{d}{b̄}& 2 \ar[bend right, swap]{l}{b ∣ p}\\  
%         \ &  
%     \end{tikzcd}
%     \]
%     It is clear that both states \(1\) and \(2\) are live,
%     since \(1\) is accepting and \(2\) have a transition to \(1\).
%     However, if we run our search algorithm: to determine whether \(1\) is live, we will need to compute the backtrack of both of its transitions. 
%     We will compute the backtrack from \(b\) first, which computes the liveness of \(2\). Thus we will mark \(1\) as searching. Yet state \(2\) only have one transition to \(1\), because \(1\) is marked as searching, the algorithm will think a infinite loop is discovered and mark \(2\) as dead, which doesn't align with the reality.
% \end{example}

% Thus, it is crucial to resolve these loops when we a designing a on-the-fly algorithm.
% In fact, we can utilize a common graph theory technique called \emph{graph condensation} to remove the loops, where it treat all thee strong connected component as a vertex as a new graph, and the edges between the components are preserved. 
% The resulting graph is a directed acyclic graph (DAG), then we can utilize a simple search to find the live state.

% \begin{definition}[Graph For sDKCT]
%     Given a sDKCT \(𝒮 ≜ ⟨S, δ, ϵ⟩\), we can construct a (potentially infinite) graph, where the vertices are \(S\) and the edge \((s, s')\) is in the graph when  connected there exists a \(p ∈ K\), s.t. \(δ(s, s', p) ≠ 0\)
% \end{definition}

% We will also recall the definition of strongly connected components 
% \begin{definition}[Walk and strongly connected components]
%     A walk from vertex \(s₁\) to vertex \(s₂\) in a graph is a sequence of vertices \([s₁, s₂, …, sₙ]\), s.t. for all \(i\), \((sᵢ, s_{i + 1})\) are edges in the graph.
%     A strongly connected component is a equivalence class on the vertices, where two vertices \(s₁\) and \(s₂\) are equivalent when there is a walk from \(s₁\) to \(s₂\) and there is a walk from \(s₂\) to \(s₁\).
% \end{definition}

% And in fact strongly connected components has strong connections with liveness of states.

% \begin{lemma}
%     By induction on the length of the walk, if there is a walk from state \(s₁\) and \(s₂\) then if \(s₂\) is live and \(s₁\) is live. 
%     Thus by definition of strongly connected component, a strongly connected component is live if and only if any of the state in the component is live. 
%     And consequently, all the states in a strongly connected component are either all dead or all live.
% \end{lemma}

% To identify the strongly connected components, we can run the Tarjan's algorithm along side the normal Hopcroft and Karp's bisimulation algorithm.
% The Tarjan's algorithm is a one pass DFS based algorithm where it assigns each state a \emph{low-link value}, at the end of the algorithm, all the algorithm with the same low-link value will be in the same strongly connected components. 
% Thus instead of marking each state with dead or live, we will mark each state with a low-link value, and each low-link value is marked with either dead or alive.
% This kind of mappings are enabled by the fact that all states in a strongly connected components are either all dead or all live.


\section{Normalized Bisimulation}

Bisimilarity implies language sematnical equivalence \[s ∼ t ⟹ ⟦s⟧ = ⟦t⟧\], however the converse doesn't hold unless we are working in a \emph{normal} GKAT coalgebra.
It is well known that two states in a normal GKAT coalgebra if and only if they have the same language semantics \[s ∼ t ⟺ ⟦s⟧ = ⟦t⟧.\]
However, instead of normalizing automatons, we can in fact, check for normality on the fly, this is important to design a derivatives based decision algorithm.

We will use a notion of normalized bisimulation, where we will enlarge the bisimulation by dead states, since all the dead states are trace equivalent.
Operationally, when we find a discrepancy during the bisimulation algorithm we will check whether the states causing the discrepancy are dead.
We can prove the correctness of this algorithm by proving that they are equivalent to normalize and then computing bisimulation.
Let \(G\) be the functor defining GKAT coalgebra: \[G ≜ (2 + (-) × K)^{\At}.\]
Given two DKCT \(𝒮, 𝒯\), and a relation on these two expression \({∼} ⊆ S × T\), we can define \({\closSim} ⊆ (2 + S × K) × (2 + T × K)\) as the smallest relation generated by the following rules: for all \(p, q ∈ K\) and states \(s' ∈ S\), \(t' ∈ T\):
\begin{mathpar}
    \inferrule[Bisim-0]{\\}{0 \closSim 0}
    \and 
    \inferrule[Bisim-1]{\\}{1 \closSim 1}
    \and 
    \inferrule[Bisim-Trans]{s' ∼ t'}{(s', p) \closSim (t', p)}
    \and
    \inferrule[Norm-Left]{s' \text{ is dead}}{(s', p) \closSim 0}
    \and 
    \inferrule[Norm-Right]{t' \text{ is dead}}{0 \closSim (t', p)}
    \and
    \inferrule[Norm-Both]{s', t' \text{ are both dead}}{(s', p) \closSim (t', q)}
\end{mathpar}
Intuitively, \({\closSim}\) enlarges the relation \(∼\) for \emph{results} of a transition. for example, it allows transition to dead states to equivalent to rejection, and so on.
This extension enables ``on-the-fly normalization'', where to determine whether \(s \closSim t\), we can simply first check for bisimulation using the bisimulation rules; and if all failed, we can check the normalization rules.

We call the bisimulation algorithm with on-the fly normalization ``\emph{normalized bisimulation}''.
This concept can be summed up nicely using diagrams.
For a relation \(∼\), then there is a straight forward embedding \((2 + {∼} × K) ↪ {\closSim}\):
This embedding generates all the elements that is formed by the bisimulation rules of \(\closSim\),
also note that \(∼\) is not restricted to live states, but dead states as well; this means that if two dead states follows the bisimulation rules, then we don't need to fall back to the normalization rules.
Since detecting whether a state is dead requires iterating through all its predecessors, we can use this property to forgo dead state detection until all the bisimulation rules failed.

The aforementioned embedding \((2 + {∼} × K) ↪ {\closSim}\) can be point-wise lifted to \(G(∼) ↪ (\At → {\closSim})\), thus our normalized algorithm can be seen as finding a normalized bisimulation \(∼\) that satisfy the following diagram:
\[
    \begin{tikzcd}[column sep=1.5cm, row sep=1cm]
        S \ar[swap]{d}{δ_𝒮}
            & ∼  \ar[dashed, swap]{d}{∃} \ar[swap]{l}{π₁} \ar{r}{π₂}
            & T \ar{d}{δ_𝒯} \\  
        (2 + S × K)^\At 
            & ({\closSim}^\At) 
                \ar[swap]{l}{{π₁}^\At} \ar{r}{{π₂}^\At}
            & (2 + T × K)^\At
    \end{tikzcd}
\]
Notice, unlike \(G(∼)\), the map \({∼} ↦ (\closSim)^\At\) is not a functor,
since it is only defined on relations.

\begin{example}
    Let's consider a example with a single primitive test \(B ≜ \{b\}\),
    thus atoms are defined as \(\At_B = \{\{b\}, ∅\}\).
    We focus on two states in the bisimulation \(s\) and \(t\).
    with their respective transition defined as follows 
    \begin{align*}
            δ_𝒮(s, \{b\}) & ≜ 0   
                & δ_𝒮(t, \{b\}) & ≜ (t', p) \\  
            δ_𝒮(s, ∅) & ≜ (s', p) 
                & δ_𝒮(t, ∅) & ≜ (t', p) 
    \end{align*}
    It is quite clear \(s\) and \(t\) will not be bisimular, however, there can be a normalized bisimulation relation between them, provided that \(s' ∼ t'\) and \(t'\) is dead: 
    \[
    \begin{tikzcd}[column sep=1.5cm, row sep=1cm]
        s \ar[swap, mapsto]{d}{δ_𝒮}
            & (s, t)  \ar[dashed, swap, mapsto]{d}{∃} \ar[swap, mapsto]{l}{π₁} \ar[mapsto]{r}{π₂}
            & t \ar[mapsto]{d}{δ_𝒯} \\  
        \begin{gathered}
            \{b\}↦ 0 \\  
            ∅ ↦ (s', p)
        \end{gathered} 
            & \begin{gathered}
                \{b\}↦ 0, (t', p) \\  
                ∅ ↦ (s', p), (t', p)
            \end{gathered} 
                \ar[swap, mapsto]{l}{{π₁}^\At} \ar[mapsto]{r}{{π₂}^\At}
            & \begin{gathered}
                \{b\} ↦ (t', p) \\  
                ∅ ↦(t', p)
            \end{gathered}
    \end{tikzcd}
    \]
    Notice that \(0 \closSim (t', p)\) because \(t'\) is dead, 
    and \((s', p) \closSim (t', p)\) because we assume that \(s' ∼ t'\). 
    Furthermore, if both \(s'\) and \(t'\) are dead, we can establish \(s' \closSim t'\) using either the \textnormal{\textsc{Bisim-Trans}} rule or \textnormal{\textsc{Norm-Both}} rule, and we are free to pick the more efficient check in our implementation.
\end{example}


\begin{theorem}[Universiality]
    Given a normalized bisimulation relation \({∼} ⊆ S × T\)
    \[
        \begin{tikzcd}[column sep=1.5cm, row sep=1cm]
            S \ar[swap]{d}{δ_𝒮}
                & ∼  \ar[dashed, swap]{d}{h} \ar[swap]{l}{π₁} \ar{r}{π₂}
                & T \ar{d}{δ_𝒯} \\  
            (2 + S × K)^\At 
                & (\closSim)^\At 
                    \ar[swap]{l}{{π₁}^\At} \ar{r}{{π₂}^\At}
                & (2 + T × K)^\At
        \end{tikzcd}
    \] 
    Then \(h\) is unique, and defined as follows: 
    \begin{align*}
        h & : {∼} → {\closSim}^\At \\
        h & (s, t, α) ≜ (δ_𝒮(s, α), δ_𝒯(s, α))
    \end{align*}
\end{theorem}

\begin{proof}
    The commutativity can be verified by computation. We only need to show uniqueness.

    The above commutative diagram implies the commutativity of the following diagram:
    \[
        \begin{tikzcd}
            & {∼} \ar{d}{h} \ar[swap]{ddl}{δ_𝒮 ∘ π₁} \ar{ddr}{δ_𝒯 ∘ π₂}& \\
            & (\closSim)^\At \ar[hook]{d}{i} & \\  
            (2 + S × K)^\At & 
                (2 + S × K)^\At × (2 + T × K)^\At
                    \ar{l}{π₁^\At} \ar[swap]{r}{π₂^\At}
                & (2 + T × K)^\At
        \end{tikzcd}
    \] 
    Since \((-)^{\At}\) is a right adjoint and right adjoints preserve limits, \((2 + S × K)^\At × (2 + T × K)^\At\) is the product of \((2 + T × K)^\At\) and \((2 + T × K)^\At\). 
    Hence, \(h ∘ i\) is the unique function to make the above diagram commute. 
    Assume we can replace \(h\) with \(g\) while preserving the commutativity of the diagram: 
    \begin{align*}
        & i ∘ h  = i ∘ g & \text{\((2 + S × K)^\At × (2 + T × K)^\At\) is a product.} \\  
        ⟹ {}& h = g & \text{\(i\) is a embedding, hence left cancelable.}
    \end{align*}
\end{proof}

\begin{definition}
    Given a DKCT \(𝒮 = ⟨S, δ⟩\), a \emph{sub-DKCT} \(𝒮' = ⟨S', δ|_{S'}⟩\) is a coagebra induced by \(S' ⊆ S\), a sub-DKCT can be characterized as a pullback square:
    \[
        \begin{tikzcd}
            S' \ar[hook]{r}{i} \ar{d}{δ|_{S'}} & S \ar{d}{δ} \\  
            G(S') \ar[hook]{r}{i} & G(S)
        \end{tikzcd}
    \]
    By the commutativity of this diagram \(i\) is also a DKCT homomorphism.
    A \emph{principle sub-DKCT} of state \(s ∈ S\), denoted \(⟨s⟩\) is the smallest sub-DKCT that contains \(s\). 
    We can show that the principle DKCT of \(s\) exactly characterize the DKCT induced by the reachable state of \(s\).
\end{definition}


%%%% NOTE: The universiality is not true, since 𝒯 will need to have the same transition structure as ⟨s⟩. 
%%%%
% \begin{definition}
%     a \emph{principle sub-DKCT} of \(𝒮\) is a ``free'' sub-DKCT generated by one element \(s\), namely, given any sub-DKCT \(𝒯\) and a element \(t ∈ 𝒯\), there is a unique DKCT homomorphism \(h: ⟨s⟩ → 𝒯\), s.t. \(h(s) = t\).

%     We denote the principle sub-DKCT of \(⟨s⟩_{𝒮}\), and we will omit the subscript \(𝒮\) if it is clear from context.
% \end{definition}

% \begin{lemma}
%     The principle sub-DKCT \(⟨s⟩_𝒮\) always exists, and it is the smallest sub-DKCT that contain \(s\).
% \end{lemma}

% \begin{proof}
%     \(⟨s⟩_𝒮\) can be constructed as the set of all the reachable state of \(s\) in \(𝒮\), specifically it is the smallest set that is generated by the following rules:
%     \begin{mathpar}
%         \inferrule{\\}{s ∈ ⟨s⟩_𝒮} \and
%         \inferrule{s₁ ∈ ⟨s⟩_𝒮 \\ ∃ α, δ(s₁, α) = (s₂, p)}{s₂ ∈ ⟨s⟩_𝒮}
%     \end{mathpar}
%     then the homomorphism \(h: ⟨s⟩ → 𝒯\) can be inductively defined as follows:
%     \begin{align*}
%         h(s) & ≜ t \\ 
%         h(s₂) & ≜ h(δ(s₁)) 
%     \end{align*}
% \end{proof}

\begin{lemma}
    A state \(s\) is live if and only if there exists a accepting state in \(⟨s⟩\);  
    and a state \(s\) is dead if and only if there is no accepting state in \(⟨s⟩\).
\end{lemma}

\begin{corollary}
    \(s\) is dead if and only if \(⟨s⟩\) is all dead.
\end{corollary}

\begin{proof}
    Take any state \(s' ∈ ⟨s⟩\), we can construct the DKCT \(⟨s'⟩\).
    Since \(⟨s'⟩\) is the smallest sub-DKCT that contains \(s'\), and \(s' ∈ ⟨s⟩\), thus \(⟨s'⟩ ⊆ ⟨s⟩\).
    Finally, because there is no accepting state in \(⟨s⟩\), there cannot be any accepting state in \(⟨s'⟩\) thus \(s'\) is also dead.
\end{proof}

In fact the normalization operation commutes with principle sub-DKCT. This result is intuitive as taking all the reachable states and then normalize is the same as normalize and then take all the reachable state.

\begin{lemma}
    Given two sub-DKCT \(𝒮₁ ⊑ 𝒮\) and \(𝒮₂ ⊑ 𝒯\), then \[𝒮₁ ⊑ 𝒮₂ ⟺ 𝒮₁ ⊆ 𝒮₂\]
\end{lemma}

\begin{proof}
    because their transition function are both restriction of \(δ_𝒮\).
\end{proof}

\begin{lemma}
    Homomorphism preserves sub-DKCT, given \(h: 𝒮 → 𝒯\):
    \[𝒮' ⊑ 𝒮 ⟹ h(𝒮') ⊑ h(𝒮) ⊑ 𝒯\]
\end{lemma}

\begin{proof}
    consequence of previous lemma.
\end{proof}

\begin{lemma}
    Homomorphism preserves principle sub-DKCT. Specifically, given a homomorphism \(h: 𝒮 → 𝒯\), 
    \[h(⟨s⟩_{𝒮}) = ⟨h(s)⟩_{𝒯},\]
    where \(h(⟨s⟩_{𝒮})\) is the image of \(⟨s⟩_{𝒮}\) under \(h\).
\end{lemma}

\begin{proof}
    Specifically, we will need to show that \(h(⟨s⟩_{𝒮})\) is the smallest sub-DKCT of \(𝒯\) that contain \(h(s)\). First by definition of image, \(h(s) ∈ h(⟨s⟩_{𝒮})\), second because \(h\) is a homomorphism \(𝒮 → 𝒯\), and \(⟨s⟩_{𝒮} ⊑ 𝒮\), thus \(h(⟨s⟩_{𝒮}) ⊑ 𝒯\).

    Finally, take any \(𝒯' ⊑ 𝒯\), and \(h(s) ∈ 𝒯'\). We take the preimage of \(𝒯'\) under \(h\),
    since \(s ∈ h^{-1}(𝒯)\), thus \(⟨s⟩_{𝒮} ⊑ h^{-1}(𝒯)\), which implies \(h(⟨s⟩_{𝒮}) ⊑ 𝒯\).
\end{proof}

\begin{corollary}
    Homomorphism preserves live/dead/accepting states.
    Given a homomorphism \(h: 𝒮 → 𝒯\) then \(s ∈ 𝒮\) is a live/dead/accepting state if and only if \(h(s) ∈ 𝒯\) is a live/dead/accepting state, respectively.
\end{corollary}

\begin{proof}
    First, homomorphism preserves accepting state by definition.
    Then because homomorphism preserves principle sub-DKCT and a state \(s\) is live if and only if there exists an accepting state \(⟨s⟩\), thus homomorphism will also preserve the liveness of \(s\).
\end{proof}

\begin{corollary}
    sub-DKCT preserves principle sub-DKCT, that is, given \(𝒮' ⊑ 𝒮\) and \(s ∈ 𝒮'\), then \[⟨s⟩_{𝒮'} = ⟨s⟩_{𝒮}.\]
\end{corollary}

\begin{proof}
    Because inclusion \(i: 𝒮' → 𝒮\) is a homomorphism, thus \[⟨s⟩_{𝒮'} = i(⟨s⟩_{𝒮'}) = ⟨i(s)⟩_𝒮 = ⟨s⟩_{𝒮}. \qedhere\]
\end{proof}

\begin{corollary}
    sub-DKCT preserves liveness, that is given \(𝒮' ⊑ 𝒮\) and \(s ∈ 𝒮'\), 
    \[s \text{ is live in \(𝒮'\)} ⟺ s \text{ is live in \(𝒮\)}\]
\end{corollary}

\begin{lemma}
    \(\norm\) is a functor, and it preserves inclusion, that is 
    \[𝒮 ⊑ 𝒯 ⟹ \norm(𝒮) ⊑ \norm(𝒯).\]
\end{lemma}

\begin{lemma}
    Given a DKCT \(𝒮\), and two sub-DKCT \(𝒮₁ ⊑ 𝒮\) and \(𝒮₂ ⊑ 𝒮\), \(𝒮₁ = 𝒮₂\) if and only if their carrier set is equal.
\end{lemma}

\begin{lemma}
    Given a DKCT \(𝒮\), its dead states induces a sub-DKCT.
\end{lemma}

\begin{theorem}
    Given a DKCT \(𝒮\) and a live state \(s ∈ 𝒮\):
    \[⟨s⟩_{\norm(𝒮)} = \norm(⟨s⟩_{𝒮}).\]
\end{theorem}

\begin{proof}
    We need to show \(\norm(⟨s⟩_{𝒮})\) is the smallest sub-DKCT in \(\norm(𝒮)\) that contains \(s\). 
    
    First, \(\norm(⟨s⟩_{𝒮})\) contains \(s\) because \(s\) is live. 
    Second, take any \(𝒯 ⊑ \norm(𝒮)\), we will use \(\overline{𝒯}\) to denote the smallest sub-DKCT of \(𝒮\) that contains all the states in \(𝒯\). 
    Since \(𝒯\) is a sub-DKCT of \(\norm(𝒮)\), \(\overline{𝒯} ∖ 𝒯\) can only contain dead states, thus \(\norm(\overline{𝒯}) = 𝒯\).
    \begin{align*}
        & ⟨s⟩_{𝒮} ⊑ \overline{𝒯} & \text{\(\overline{𝒯}\) contains \(s\)} \\  
        ⟹ {}& \norm(⟨s⟩_{𝒮}) ⊑ \norm(\overline{𝒯}) & \text{monotonicity of \(\norm\)} \\  
        ⟹ {}& \norm(⟨s⟩_{𝒮}) ⊑ 𝒯 & \norm(\overline{𝒯}) = 𝒯
    \end{align*}
\end{proof}

We will show this by establishing the equivalence between ``normalized bisimulation'' and ``bisimulation in normalized coalgebra''.
Given a GKAT coalgebra \(𝒮\), we can normalize it via removing the dead states and reroute all the transitions to dead state as direct rejections.
Similarly, any relation \({∼} ⊆ 𝒮 × 𝒯\) can be normalized by filtering out all the states that are live:
\[\norm(∼) ≜ \{(s, t) ∣ \text{both \(s\) and \(t\) are live states}\}.\]
Thus there is a natural embedding \(\norm(∼) ↪ {∼}\) by inclusion. 
Similarly, there is a embedding \(G(\norm(∼)) → (\closSim)^\At\) by lifting the following embedding point-wise via \((-)^\At\):
\begin{align*}
    2 + {\norm(∼)} × K & ↪ {\closSim} \\  
    0 & ↦ (0, 0) \\
    1 & ↦ (1, 1) \\
    (s, t), p & ↦ (s, p), (t, p) 
\end{align*}
These two embeddings allows us to construct the following pullback square:
\[
    \begin{tikzcd}
        \norm(∼) \ar[hook]{r}{i} \ar[dashed, swap]{d}{\norm(h)} & ∼ \ar{d}{h}\\  
        G(\norm(∼)) \ar[hook]{r}{i} & (\closSim)^\At
    \end{tikzcd}
\]

\begin{theorem}
    A normalized bisimulation induces a bisimulation in the normal coalgebras.
    That is 
    \[
        \begin{tikzcd}[column sep=1cm, row sep=1cm]
            S \ar[swap]{d}{δ_𝒮}
                & ∼  \ar[dashed, swap]{d}{(δ_𝒮, δ_𝒯)} \ar[swap]{l}{π₁} \ar{r}{π₂}
                & T \ar{d}{δ_𝒯} \\  
            G(S) 
                & {\closSim}^\At 
                    \ar[swap]{l}{{π₁}^\At} \ar{r}{{π₂}^\At}
                & G(T)
        \end{tikzcd}
        ⟹
        \begin{tikzcd}[column sep=1cm, row sep=1cm]
            \norm(S) \ar[swap]{d}{δ_{\norm(𝒮)}}
                & \norm(∼)  \ar[dashed, swap]{d}{\norm(h)} \ar[swap]{l}{π₁} \ar{r}{π₂}
                & \norm(T) \ar{d}{δ_{\norm(𝒯)}} \\  
            G(\norm(S)) 
                & G(\norm(∼)) 
                    \ar[swap]{l}{G(π₁)} \ar{r}{G(π₂)}
                & G(\norm(T))
        \end{tikzcd}
    \]
\end{theorem}

\begin{proof}
    By computation.
\end{proof}

\begin{lemma}
    Given a normalized bisimulation \({∼} ⊆ 𝒮 × 𝒯\), and a pair of state \(s ∼ t\), then the range of \(π₁: {∼} → S\), will cover all the live states in \(⟨s⟩\);
    similarly for the state \(t ∈ 𝒯\).
\end{lemma}

\begin{proof}
    let \(\norm(∼)|_{⟨s⟩}\) be all the live elements of \(∼\) restricted to \(⟨s⟩\):
    \[{\norm(∼)|_{⟨s⟩}} ≜ \{(s', t') ∈ {∼}∣ s' ∈ ⟨s⟩, \text{both \(s'\) and \(t'\) are live}\}.\]
    since all the live states in \(⟨s⟩\) is the carrier of \(\norm(⟨s⟩)\),
    we only need to show \(π₁: {\norm(∼)|_{⟨s⟩}} → ⟨s⟩\) is surjective.
    
    Since \(∼\) is a normalize bi-simulation, then \(\norm(∼)\) is a bisimulation,
    and the following diagram commute by computation:
    \[
    \begin{tikzcd}
        \norm(∼)|_{⟨s⟩} \ar{r}{π₁} \ar[swap]{d}{h} 
            & \norm(⟨s⟩) \ar{d}{δ_{\norm(𝒮)}}\\  
        G(\norm(∼)|_{⟨s⟩}) \ar{r}{G(π₁)} & G(\norm(⟨s⟩))
    \end{tikzcd}
    \]
    Because of above diagram, \(\Img(π₁) ⊆ \norm(⟨s⟩)\), the range of \(π₁\), also forms a sub-DKCT of \(\norm(𝒮)\) with the transition: \(δ_{\norm(𝒮)}: \Img(π₁) → G(\Img(π₁))\)
    then there are two cases:
    \begin{itemize}
        \item if \(s\) is dead, then \(\norm(⟨s⟩)\) is empty, thus \(π₁\) is surjective,
        \item if \(s\) is live, then \(\norm(⟨s⟩) = ⟨s⟩_{\norm(𝒮)}\), because \(\Img(π₁)\) is a sub-DKCT and contains \(s\), thus \[\norm(⟨s⟩) = ⟨s⟩_{\norm(𝒮)} ⊑ \Img(π₁).\] 
        Hence \(\Img(π₁)\) covers \(\norm(⟨s⟩)\) and \(π₁\) is surjective.
    \end{itemize}
\end{proof}


% \begin{theorem}
%     Given a normalized bisimulation \({∼} ⊆ 𝒮 × 𝒯\), and two states \(s ∼ t\), then \(∼\) can be restricted to the principle sub-DKCT \(⟨s⟩\) and \(⟨t⟩\): 
%     \[
%     \begin{tikzcd}
%         ⟨s⟩ \ar[swap]{d}{δ_𝒮 |_{⟨s⟩}}
%             & ∼|_{⟨s⟩ × ⟨t⟩} \ar[swap]{l}{π₁} \ar{r}{π₂} \ar{d}{h}
%             & ⟨t⟩ \ar{d}{δ_𝒮 |_{⟨s⟩}} \\  
%         G(⟨s⟩)
%             & (\overline{∼|_{⟨s⟩ × ⟨t⟩}})^{\At} \ar[swap]{l}{(π₁)^\At} \ar{r}{(π₂)^\At} 
%             & G(⟨t⟩)
%     \end{tikzcd}
%     \]
%     In this case, \(π₁\) and \(π₂\) is surjective.
% \end{theorem}

% \begin{proof}
%     Take any element \(s' ∈ \Img(π₁)\), we can show that \(δ_𝒮(s') ∈ G(Img(π))\),
%     in other word, \(\Img(π₁)\) from a sub-DKCT of \(𝒮\).
%     NTS \(δ_𝒮(s', α) = π₁(h(s', α)) ∈ 2 + Img(π) × K\).


%     Note that because since \(s ∼ t\), \(\Img(π₁)\) contains \(s\) and \(\Img(π₁)\) contains \(t\).
%     Because \(⟨s⟩\) and \(⟨t⟩\) are the smallest sub-DKCTs that contain \(s\) and \(t\) respectively, thus the image of \(π₁\) is \(⟨s⟩\) and the image of \(π₂\) is \(⟨t⟩\), hence both \(π₁\) and \(π₂\) are surjective.
% \end{proof}

\begin{theorem}
    Given a dead state \(s\) and a live state \(t\), there doesn't exists a normalized bisimulation \(∼\) s.t. \(s ∼ t\) or \(t ∼ s\).
\end{theorem}

\begin{proof}
    WLOG we will only prove that \(s ∼ t\) will lead to a contradiction.
    We can restrict the simulation diagram of \(∼\) to \(⟨s⟩\) and \(\norm(⟨t⟩)\),
    let \[∼_{s, t̂} = \{s', t' ∣ s' ∼ t', s' ∈ ⟨s⟩, t' ∈ \norm(⟨t⟩)\}.\]
    Note that only \(𝒯\) is restricted to \(\norm(⟨t⟩)\); while \(𝒮\) is restricted to \(⟨s⟩\), without \(\norm\). 
    This discrepancy is because \(s\) is dead, thus \(\norm(⟨s⟩)\) is empty. 
    If we restrict \(∼\) to \(\norm(⟨t⟩) × \norm(⟨s⟩)\), then there will be no element in the restriction, since \(\norm(⟨t⟩) × \norm(⟨s⟩)\) is empty.

    We can show that \(∼_{s, t̂}\) form a normalized bisimulation between \(⟨s⟩\) and \(\norm(⟨t⟩)\).
    \[
        \begin{tikzcd}[column sep=1cm, row sep=1cm]
            ⟨s⟩ \ar[swap]{d}{δ_𝒮}
                & ∼_{s, t̂} \ar{d}{(δ_𝒮, \norm(δ_𝒯))} \ar[swap]{l}{π₁} \ar{r}{π₂}
                & \norm(⟨t⟩) \ar{d}{\norm(δ_𝒯)} \\  
            G(⟨s⟩) 
                & {\overline{∼_{s, t̂}}}^\At 
                    \ar[swap]{l}{{π₁}^\At} \ar{r}{{π₂}^\At}
                & G(\norm(⟨t⟩))
        \end{tikzcd}
    \]
    Then we can perform epi-mono factorization on the right square to obtain the range of \(π₂\):
    \[
        \begin{tikzcd}[column sep=1cm, row sep=1cm]
            ∼_{s, t̂} \ar[swap]{d}{(δ_𝒮, \norm(δ_𝒯))} \ar{r}{π₂}
                & \Img(π₂) \ar[hook]{r}{i} \ar{d}{\norm(δ_𝒯)}
                & \norm(⟨t⟩) \ar{d}{\norm(δ_𝒯)} \\  
            {\overline{∼_{s, t̂}}}^\At  \ar{r}{π₂^{\At}}
                & G(\Img(π₂)) \ar[hook]{r}{G(i)}
                & G(\norm(⟨t⟩))
        \end{tikzcd}
    \]
    Thus, \[\Img(π₂) ⊑ \norm(⟨t⟩) ⊑ \norm(𝒯).\]
    Recall that \(\norm(⟨t⟩_{𝒯}) = ⟨t⟩_{\norm(𝒯)}\), hence \(\norm(⟨t⟩)\) is the smallest sub-DKCT of \(\norm(𝒯)\),  since \(s ∼ t\), thus \(t ∈ \Img(π₂)\).
    Hence \(\Img(π₂) ⊒ \norm(⟨t⟩)\), thus \(π₂\) is surjective.

    Since \(t\) is a live state, hence there exists an accepting state \(t'\) in \(\norm(⟨t⟩)\); 
    because \(s\) is a dead state, thus all the states in \(⟨s⟩\) is dead.
    Because \(π₂: {∼_{s, t̂}} → T\) is surjective, there exists a dead state \(s' ∈ ⟨s⟩\) s.t. \(s' ∼ t'\).
    However, a dead state cannot be normally bisimilar to a accepting state, since \(((s', p), 1) ∉ \overline{∼_{s, t̂}}\) for all dead state \(s'\) and action \(p\).
\end{proof}

\begin{theorem}
    Homomorphism reflects normalized bisimulation. Let \(h: 𝒮₁ → 𝒮₂\), and a normalized bisimulation \({∼} ⊆ 𝒮₂ × 𝒯\), then there exists a normalized bisimulation \({∼ₕ}: 𝒮₁ × 𝒯\).
    And similarly for \({∼} ⊆ 𝒯 × 𝒮₂\).
\end{theorem}

\begin{proof}
    \(∼ₕ\) can be defined as follows: 
    \[{∼ₕ} ≜ \{(s, t) ∣ h(s) ∼ t\}.\]
    Then the function \(h × id: {∼ₕ} → {∼}\), can be lifted to \({{\overline{∼ₕ}}^\At} → {\closSim^\At}\):
    \[
        \begin{tikzcd}[column sep=2.5cm]
            ∼ \ar[swap]{d}{(δ_{𝒮₂}, δ_𝒯)}
                & ∼ₕ \ar[swap]{l}{h × id} \ar{d}{(δ_{𝒮₁}, δ_𝒯)}   \\ 
            \closSim^\At
                & {\overline{∼ₕ}}^\At \ar[dashed]{l}{((id + h × id) × id)^\At}
        \end{tikzcd}
    \]
    The generated function \((id + h × id) × id: {\overline{∼ₕ}} → {\closSim}\) is indeed well-defined by case analysis on the input in \(∼ₕ\), and also by the fact that homomorphism like \(h\) preserves liveness.
\end{proof}

\begin{definition}
    A guarded language \(L\) over alphabet \(K, B\) is deterministic when given a list of atoms \(α₀, α₁, α₂, …, αₙ\),
    there is at most one word in the language \(w ∈ L\) that has the form:
    \[α₀ p₁ α₁ … pₙ αₙ \text{ for some } pᵢ ∈ K\]
\end{definition}

\begin{theorem}
    the set of deterministic guarded language over the alphabet \(K, B\): \(𝒢_{K, B}\) is a DKCT;  
    and the trace semantics \(⟦-⟧: 𝒮 → 𝒢\) is a homomorphism.
\end{theorem}

\begin{theorem}[soundness and completeness]
    the trace of two state \(s ∈ 𝒮\) and \(t ∈ 𝒯\) are trace equivalent if and only if there exists a normalized bisimulation between them
    \[⟦s⟧ = ⟦t⟧ ⟺ \text{there exists a normalized bisimulation \(∼\) s.t. } s ∼ t.\]
\end{theorem}

\begin{proof}
    The \(⟸\) direction can be shown by case analysis on the liveness of \(s\) and \(t\):
    \begin{itemize}
        \item If both \(s\) and \(t\) are live, 
            \[s ∼ t ⟹ (s, t) ∈ \norm(∼) ⟹ ⟦s⟧ = ⟦t⟧.\]
        \item If one of \(s\) and \(t\) is live, and the other is dead, then \(s ∼ t\) cannot hold.
        \item If both \(s\) and \(t\) are dead, since dead states don't have any trace:
            \[⟦s⟧ = ⟦t⟧ = ∅.\]
    \end{itemize}
    
    \(⟹\) direction can be shown by constructing the identity normalized bisimulation on languages: \({∼_{id}} ⊆ 𝒢 × 𝒢\) and then reflect both side by the language semantics \(⟦-⟧: 𝒮 → 𝒢\) and \(⟦-⟧: 𝒯 → 𝒢\). Thus we obtain a normalized bisimulation on \(𝒮\) and \(𝒯\).
\end{proof}

\begin{corollary}
    The language equivalence is the maximal normalized bisimulation.  
\end{corollary}

\begin{corollary}
    There exists a normalized bisimulation s.t. \(s ∼ t\) if and only if there exists a normalized bisimulation equivalence \(≡\) s.t. \(s ≡ t\).
\end{corollary}

\begin{proof}
    take the \(≡\) to be language equivalence.
\end{proof}

\begin{corollary}
    The trace semantics of a state is preserved in sub-DKCTs, that is given \(𝒮 '⊑ 𝒮\) and a state \(s ∈ 𝒮'\), \(⟦s⟧_{𝒮} = ⟦s⟧_{𝒮'}\)
\end{corollary}

\begin{proof}
    We only need to exhibit a normalized bisimulation between \(𝒮'\) and \(𝒮\):
    \[s ∼ t \text{ when \(s = t\) or \(s\) and \(t\) are both dead}.\]
    To show that the relation \(∼\) is a normalized bisimulation, we only need to check the commutativity of the following diagram:
    \[
    \begin{tikzcd}[column sep=1cm, row sep=1cm]
        𝒮' \ar[swap]{d}{δ_𝒮}
            & ∼ \ar{d}{(δ_𝒮, δ_𝒮)} \ar[swap]{l}{π₁} \ar{r}{π₂}
            & 𝒮 \ar{d}{δ_𝒮} \\  
        G(𝒮') 
            & {\overline{∼}}^\At 
                \ar[swap]{l}{{π₁}^\At} \ar{r}{{π₂}^\At}
            & G(𝒮)
    \end{tikzcd}
    \]
    The commutativity is apparent by computation. The function \((δ_𝒮, δ_𝒮): {∼} → {\overline{∼}}^\At\) is well-defined, by case analysis on the input:
    \begin{itemize}
        \item if \(s = t\), then \(δ_𝒮(s, α) = δ_𝒮(t, α)\), hence will be in \(\overline{∼}\) for all \(α\).
        \item if both \(s\) and \(t\) are dead, then for all \(α ∈ \At\) both \(δ_𝒮(s, α)\) and \(δ_𝒮(t, α)\) are will either transition to a dead state or reject, thus the results will also be in \(\overline{∼}\).
    \end{itemize}
\end{proof}


Since sub-DKCT preserves semantics, we only need to exhibit a normalized bisimulation \({∼} ⊆ ⟨s⟩ × ⟨t⟩\), to shrink the size of the bisimulation:
\[
    \begin{tikzcd}[column sep=1cm, row sep=1cm]
        ⟨s⟩ \ar[swap]{d}{δ_𝒮}
            & ∼_{s, t} \ar{d}{(δ_𝒮, δ_𝒯)} \ar[swap]{l}{π₁} \ar{r}{π₂}
            & ⟨t⟩ \ar{d}{δ_𝒯} \\  
        G(⟨s⟩) 
            & {\overline{∼_{s, t}}}^\At 
                \ar[swap]{l}{{π₁}^\At} \ar{r}{{π₂}^\At}
            & G(⟨t⟩)
    \end{tikzcd}
\]
The because sub-DKCT preserves trace semantics, thus the completeness result still holds: 
\[⟦s⟧_𝒮 = ⟦t⟧_𝒯 ⟺ ⟦s⟧_{⟨s⟩} = ⟦t⟧_{⟨t⟩} ⟺ \text{there exists } {∼} ⊆ ⟨s⟩ × ⟨t⟩ \text{ such that } s ∼ t.\]

Finally, to construct a normalized bisimulation using programs, we will need the following inductive construction theorem
\begin{theorem}[Inductive Construction]
    Given two DKCT \(𝒮\) and \(𝒯\), and two of their elements \(s ∈ 𝒮\) and \(t ∈ 𝒯\),
    there exists a normalized bisimulation \(s ∼ t\) between \(⟨s⟩\) and \(⟨t⟩\), if and only if either both \(s\) and \(t\) are dead or for all \(α ∈ \At\), all of the following holds:
    \begin{enumerate}
        \item \(δ_{𝒮}(s, α) = \accept ⟺ δ_{𝒯}(t, α) = \accept\);
        \item\label{itm: transition condition} If \(δ_{𝒮}(s, α) = (s', p)\) and \(δ_{𝒯}(t, α) = (t', p)\), then and there exists a normalized bisimulation \({∼_{s',t'}}\) on \(⟨s'⟩\) and \(⟨t'⟩\), s.t. \(s' ∼_{s',t'} t'\);
        \item If \(δ_{𝒮}(s, α) = (s', p)\) and \(δ_{𝒯}(t, α) = (t', q)\), s.t. \(p ≠ q\), then both \(s'\) and \(t'\) are dead;
        \item \(s\) reject \(α\) or transition to a dead state via \(α\) if and only if \(t\) rejects \(α\) or transition to a dead state via \(α\).
    \end{enumerate}
\end{theorem}

\begin{proof}
    We first prove the \(⟹\) direction: if there exists a normalized bisimulation \(∼\), then for all \(α ∈ \At\), \(δ_{𝒮}(s, α) \closSim δ_{𝒯}(t, α)\). And by unfolding the definition of \(\closSim\), we can obtain all the conditions we desired. 

    For the \(⟸\) direction, we can explicitly construct \(∼\) as the union of all the normalized bisimulations \(∼_{s', t'} ⊆ ⟨s'⟩ × ⟨t'⟩\): 
    \[{∼} = \{(s, t)\} ∪ \{{∼_{s', t'}} ∣ ∃ α ∈ \At, p ∈ K, δ_𝒮(s, α) = (s', p) \text{ and } δ_𝒯(t, α) = (t', p)\}.\]
    Then, we will need to show \(∼\) is indeed a normalized bisimulation on \(⟨s⟩\) and \(⟨t⟩\), that is for all \(s' ∈ ⟨s⟩\) and \(t' ∈ ⟨t⟩\):
    \[s' ∼ t' ⟹ δ_𝒮(s', α) \closSim δ_𝒯(t', α).\]
    We only need to show the above implication for \(s ∼ t\), as other element is already in some normalized bisimulation between sub-DKCTs of \(𝒮\) and \(𝒯\).
    And the implication \(s ∼ t ⟹ δ_𝒮(s', α) \closSim δ_𝒯(t', α)\) can be proven by unfolding the definition of \(\closSim\).
\end{proof}

Given a state \(s ∈ 𝒮\) we can run a simple depth-first search in \(⟨s⟩\) to determine whether \(s\) is dead. Specifically recall that \(s\) is live if and only if there exists an accepting state in \(s\), and if \(s\) is dead, then all of \(⟨s⟩\) is dead
\begin{lstlisting}
(** return whether the state is accepting*)
let is_accept (s: state): bool = 
    [*\(∃ α ∈ \At, δ(s, α) = \accept\)*]

(** a mutable set to keep track of states 
that has been explored by check_dead function*)
let explored = [*\(∅\)*]
(** return a all the states in [*\(⟨s⟩\)*] if s is dead, 
otherwise return None*)
let check_dead (s: state): state set option =
    (* [*\(⟨s⟩\)*] has all be explored *)
    if s [*\(∈\)*] explored then [*\(∅\)*]

    (* exploring [*\(⟨s⟩\)*] *)
    else for [*\(α ∈ \At\)*]:
        if [*\(δ(s, α) = \accept\)*] then None 
        else if [*\(δ(s, α) = (s', p)\)*] then 
            if check_dead s' = None then None 
            else explored := explored [*\(∪\)*] check_dead s'
        (* [*\(δ(s, α) = \reject\)*] case, skip *)

    (* finished exploring [*\(⟨s⟩\)*] *)
    explored [*\(∪\)*] {s}
\end{lstlisting}
To achieve better efficiency, we can cache all the dead state we found:
\begin{lstlisting}
(** a mutable set to keep track of all the found dead states *)
let dead_states = [*\(∅\)*]

(** a function to check whether a state is dead *)
let is_dead (s: state): bool =
    if s [*\(∈\)*] dead_states then true 
    else if check_dead s = None then false 
    else 
        dead_states := dead_states [*\(∪\)*] check_dead s
        return true
\end{lstlisting}

Thus our algorithm can be directly obtained from previous theorem, with couple modifications
\begin{itemize}
    \item  we will finding normalized bisimulation equivalence \(∼\) in a DKCT with transition function \(δ\), as oppose to in \(𝒮\) and \(𝒯\). 
    This approach is general enough: when given \(𝒮\) and \(𝒯\), we can merge them via coproduct \(𝒮 + 𝒯\), where both \(𝒮\) and \(𝒯\) are sub-DKCT of \(𝒮 + 𝒯\), thus preserving the semantics of all the states.
    \item we will find a bisimulation equivalence instead of bisimulation relation, this allows us to use union-find structure to keep track of related states. In particular, the \texttt{union} function will mark two states as equivalent, and \texttt{eq} function will return whether two states has the same representative in the union-find.
\end{itemize}  

\begin{lstlisting}
(** computing the normalized bisimulation equivalence using union find *)
let equiv (s: state) (t: state): bool = 
    (* if s and t are already in the normalized bisimulation equivalence *)
    if eq s t then true else 

    (* checking if they are both dead *)
    if s [*\(∈\)*] dead_states then is_dead t else 
    if t [*\(∈\)*] dead_states then is_dead s else 
    
    (* all of the following condition needs to be true for all atoms *)
    forall ([*\(α ∈ \At\)*]): 
        match [*\(δ(s, α), δ(t, α)\)*] with 
            [*\(\accept, \accept\)*] -> true 
            [*\((s', p), (t', q)\)*] -> 
                if p = q 
                    (* mark s and t as bisimular and check the rest*)
                    then union s t; equiv s' t' 
                    else is_dead s' && is_dead t'
            [*\((s', p), \reject\)*] -> is_dead s'
            [*\(\reject, (t', p)\)*] -> is_dead t'
            [*\(\reject, \reject\)*] -> true 
            _ -> false
\end{lstlisting}
TODO: I think I still need to use one of those algorithm package... 

The correctness of this algorithm can be exhibited by the following induction invariant:
\[\texttt{equiv s t} ⟺ \text{there exists a normalized bisimulation equivalence \(∼\) s.t. \(s ∼ t\)}\]
Then by the soundness and completeness of normalized bisimulation:
\[\texttt{equiv s t} ⟺ ⟦s⟧ = ⟦t⟧.\]






% \section{Definitions}

% A deterministic symbolic Kleene Coalgebra with Tests (dsKCT) \(𝒮\) over a finite alphabet \(K\) and a boolean algebra \(ℬ\) is a coalgebra with with the following operation:
% \[δ: 𝒮 → 𝒮 → ℬ.\]
% Following notations in previous works,
% we will sometimes write \(δ_{p}: 𝒮 → 𝒮 → \BExp(B)\) for \(p ∈ K\).

% The boolean term algebra over \(B\) formed by all the boolean terms over \(B\) defined by 
% \[e ≜ b ∈ B ∣ e₁ ∨ e₂ ∣ e₁ ∧ e₂ ∣ ē,\]
% modulo boolean algebra equalities. 
% The operations in the boolean term algebra is syntactical,
% for example, the logical conjunction of term \(e₁\) and \(e₂\)
% in the term algebra is the term \(e₁ ∧ e₂\).
% The boolean term algebra is a free boolean algebra, 
% this means that all the set map \(Î: B → ℬ\) for any boolean algebra \(ℬ\)
% can be lifted to a unique boolean algebra homomorphism \(I: \BExp(B) → ℬ\),
% where \[∀ b ∈ B, I(b) = Î(b).\]

% A sKCT homomorphism is a map \(h: 𝒮 → 𝒮'\) where it preserves both operations:
% \[
%     \begin{tikzcd}
%         𝒮 \ar{d}{ϵ} \ar{r}{h} & 𝒮' \ar{dl}{ϵ} \\  
%         \BExp(B)
%     \end{tikzcd} \qquad \qquad
%     ∀ p ∈ K, 
%     \begin{tikzcd}[column sep=1.5cm]
%         𝒮 \ar{d}{δ_{p}} \ar{r}{h} & 𝒮' \ar{d}{δ_{p}} \\  
%         \BExp(B)^𝒮 & \BExp(B)^{𝒮'} \ar{l}{\BExp(B)^{h}}
%     \end{tikzcd}    
% \]
% where \(\BExp(B)^{h}\) is defined as 
% \begin{align*}
%     \BExp(B)^{h} & : (𝒮' → \BExp(B)) → (𝒮 → \BExp(B)) \\
%     \BExp(B)^{h} & (f) ≜ f ∘ h.
% \end{align*}
% Notice the function \(\BExp(B)^{h}\) has the type \(\BExp(B)^{𝒮'} → \BExp(B)^𝒮\)
% instead of the conventional \(\BExp(B)^{𝒮} → \BExp(B)^{𝒮'}\),
% this is because \(\BExp(B)^{(-)}\) is a contravariant functor.

% Similarly, sKCT bisimulation \(≡\) between \(𝒮\) and \(𝒮'\) is a 
% relation \({≡} ⊆ 𝒮 × 𝒮'\) that makes the following diagrams commutes:
% \[
%     \begin{tikzcd}
%         𝒮 \ar[swap]{dr}{ϵ} & 
%             ≡ \ar[swap]{l}{π₁} \ar{r}{π₂}& 
%             𝒮' \ar{dl}{ϵ} \\  
%         & \BExp(B) & 
%     \end{tikzcd} \qquad \qquad
%     ∀ p ∈ K, 
%     \begin{tikzcd}[column sep=1.5cm]
%         𝒮 \ar{d}{δ_{p}} 
%             & ≡ \ar[swap]{l}{π₁} \ar{r}{π₂}
%             & 𝒮' \ar{d}{δ_{p}} \\  
%         \BExp(B)^𝒮 \ar{r}{\BExp(B)^{(π₁)}}
%         & \BExp(B)^{(≡)} & \BExp(B)^{𝒮'} \ar[swap]{l}{\BExp(B)^{(π₂)}}
%     \end{tikzcd}    
% \]

% \begin{example}
%     Consider the following two sKCT
%     \[
%     \begin{tikzpicture}
%         \node (0) [state] {0};
%         \node (1) [state, above right = of 0] {1};
%         \node (2) [state, below right = of 0] {2};
%         \path[->] (0) edge node[above]{\(b p\)} (1);
%         \path[->] (0) edge node[above]{\(b̄ p\)} (2);   
%         \draw[->, double] (0) -- +(0,1) node[left]{\(1\)};
%         \draw[->, double] (1) -- +(1,0) node[above]{\(1\)};
%         \draw[->, double] (2) -- +(1,0) node[above]{\(1\)};
%     \end{tikzpicture}
%     \qquad \qquad
%     \begin{tikzpicture}
%         \node (0) [state] {0};
%         \node (1) [state, above right = of 0] {1};
%         \node (2) [state, below right = of 0] {2};
%         \path[->] (0) edge node[above]{\(c p\)} (1);
%         \path[->] (0) edge node[above]{\(c̄ p\)} (2);   
%         \draw[->, double] (0) -- +(0,1) node[left]{\(1\)};
%         \draw[->, double] (1) -- +(1,0) node[above]{\(1\)};
%         \draw[->, double] (2) -- +(1,0) node[above]{\(1\)};
%     \end{tikzpicture}
%     \]
%     They are bisimilar
% \end{example}

% \begin{proof}
%     It is clean that both of these sKCT unfolds to the same KCT,
%     and they both accepts languages \(\{α p β ∣ α, β ∈ \At\}\). 
%     However, their transition has some overlaps, and some distinction.

%     we consider the following bisimulation \(\{(0,0)\} ∪ \{(a, b) ∣ a, b ∈ \{1,2\}\}\)
% \end{proof}


% \section{Semantics And Relation with KCT}

% There are several representations of free boolean algebra 
% and all of them are isomorphic. 
% For example a well-known representation of free boolean algebra is \(2^\At\),
% Notice 
% \begin{align}
%     ⋁ \{α ∣ α ≤ ϕ\} & = ϕ & \text{for } ϕ ∈ \BExp(B), 
%         \label{the: lor of atom}\\  
%     \{α ∣ α ≤ ⋁ A\} & = A & \text{for } A ∈ 2^{\At}.
%         \label{the: atom of lor}
% \end{align}
% Then the isomorphism \(f: \BExp(B) ⥲ 2^\At\) is defined by 
% the following function \(at(ϕ) ≜ \{α ∣ α ≤ ϕ\}\) with the inverse \(at^{-1}(A) ≜ ⋁ A\).

% The classical way to provide semantics to a certain coalgebra is by finding the final coalgebra.
% \begin{definition}[Final sKCT]
%     The final sKCT is formed by set of guarded strings \(2^{\GS}\), 
%     with the operations defined as follows:
%     \begin{align*}
%         ϵ(l) & ≜ ⋁ \{α ∣ α ∈ l\} & 
%         δₚ(l)(l') & ≜ ⋁ \{α ∣ ∃ w ∈ l', α p w ∈ l\}
%     \end{align*}
% \end{definition}

% \begin{proof}
%     We need to show that for all sKCT \(𝒮\), there exists a unique homomorphism \(L\):
%     \[
%         \begin{tikzcd}
%             𝒮 \ar{d}{ϵ} \ar[dashed]{r}{L} & 2^{\GS} \ar{dl}{ϵ} \\  
%             \BExp(B)
%         \end{tikzcd} \qquad \qquad
%         ∀ p ∈ K, 
%         \begin{tikzcd}[column sep=1.5cm]
%             𝒮 \ar{d}{δ_{p}} \ar[dashed]{r}{L} & 2^{GS} \ar{d}{δ_{p}} \\  
%             \BExp(B)^𝒮 & \BExp(B)^{2^{GS}} \ar[dashed]{l}{\BExp(B)^{L}}
%         \end{tikzcd}
%     \]
%     We can simplify these two diagrams as follows
%     \begin{itemize}
%         \item If the first diagram commutes, then for all \(s ∈ 𝒮\), 
%             \(ϵ(s) = ϵ(L(s)) = ⋁ \{α ∣ α ∈ L(s)\}\), which implies
%             \[α ≤ ϵ(s) ⟺ α ≤ ⋁ \{α ∣ α ∈ L(s)\} ⟺ α ∈ L(s).\]
%             Furthermore, if \(α ≤ ϵ(s) ⟺ α ∈ L(s)\), we have 
%             \[ϵ(L(s)) = ⋁ \{α ∣ α ∈ L(s)\} = ⋁ \{α ∣ α ≤ ϵ(s)\} = ϵ(s);\]
%             thus the first diagram commutes.
%             Therefore, the first diagram commutes if and only if the following equivalence holds:
%             \[α ≤ ϵ(s) ⟺ α ∈ L(s).\]
%         \item If the second diagram commutes, then for all \(s, s' ∈ 𝒮\), 
%             \[δₚ(s)(s') = \BExp(B)^{L}(δₚ(L(s)))(s') 
%                 = δₚ(L(s))(L(s')) 
%                 = ⋁ \{α ∣ ∃ w ∈ L(s'), α p w ∈ L(s)\},\]
%             which would imply 
%             \[α p w ∈ L(s) ⟺ ∃ s' ∈ 𝒮, w ∈ L(s') ∧ α ≤ δₚ(s)(s').\]
%     \end{itemize}




%     where the language \(L(s)\) for each state \(s\) is coinductively defined as follows:
%     \[L(s) ≜ \{α ∣ α ≤ ϵ(s)\} ∪ \{α p w ∣ p ∈ K, s' ∈ 𝒮, α ≤ δₚ(s)(s'), w ∈ L(s')\}.\]
%     Notice the following equivalence can be observed from the definition
%     \begin{align*}
%         α ∈ L(s) & ⟺ α ≤ ϵ(s), \\
%         α p w ∈ L(s) & ⟺ ∃ s' ∈ 𝒮, w ∈ L(s') ∧ α ≤ δₚ(s)(s').
%     \end{align*}
    
%     We first show that the diagram commutes:
%     \begin{align*}
%         ϵ(L(s)) & = ⋁ \{α ∣ α ∈ L(s)\} \\
%             & = ⋁ \{α ∣ α ≤ ϵ(s)\} 
%             = ϵ(s);\\   
%         \BExp(B)^{L}(δₚ(L(s)))(s')
%             & = δₚ(L(s))(L(s')) \\
%             & = ⋁ \{α ∣ ∃ w ∈ L(s'), α p w ∈ L(s)\} \\  
%             & = ⋁ \{α ∣ α ≤ δₚ(s)(s')\} 
%             = δₚ(s)(s').
%     \end{align*}

%     We then show that such a homomorphism is unique,
%     assume that \(L': 𝒮 → 2^{\GS}\), 
%     we will show that given any guarded word \(w ∈ 2^{\GS}\), and state \(s ∈ 𝒮\)
%     \[w ∈ L'(s) ⟺ w ∈ L(s),\]
%     by induction on \(w\):
%     \begin{itemize}
%         \item If \(w = α\) for some atom \(α\),
%             then \(w ∈ L'(s) \)
%     \end{itemize}
% \end{proof}

% Since \(\BExp(B) ≅ 2^\At\) in set, 
% we can develop the following natural isomorphism:
% \begin{align*}
%     ϵ & : 𝒮 → \BExp(B) ≅ 𝒮 → \At → 2; \\  
%     δ & : 𝒮 → K → 𝒮 → \BExp(B) ≅ 𝒮 → K → 𝒮 → \At → 2 
%         ≅ 𝒮 → \At → K → 2^{𝒮}.
% \end{align*} 
% In other word, a symbolic Kleene Coalgebra with Tests is a ``non-deterministic'' KCT,
% in the sense that given a atom and a primitive action, it can transition 
% to multiple states non-deterministically.
% There we can apply the following determination procedure to it:
% \begin{align*}
%     ϵ̂ &:  2^𝒮 → \At → 2 & δ̂ &: 2^𝒮 → \At → K → 2^{𝒮} \\  
%     ϵ̂_{α} & (S) ≜ ∃ s ∈ S, ϵ(s) = 1, & 
%     δ̂_{α p} & (S) ≜ \{s' ∣ δ_{α p}(s) = s', s ∈ S\}.
% \end{align*}
% In other words, given a sKCT \(𝒮\), then we can construct a KCT \(2^{𝒮}\).



\end{document}