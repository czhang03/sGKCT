# Overall Response

We express our gratitude for the valuable feedback received from reviewers. 
We will carefully address the points raised and implement the necessary changes to our paper.

First, we address concerns surrounding lazy normalization. 
The classical algorithm guarantees a full traversal of the coalgebra during liveness checking prior to bisimulation checking, our algorithm invokes bisimulation and only traverses the reachable states of the discrepancies.
Therefore, lazy liveness checking consistently visits fewer states, even for positive results. 
Additionally, lazy liveness checking enables on-the-fly coalgebra generation using derivatives.

While our algorithms seem intuitive, our proofs are not trivial. 
The simple proofs are enabled by the design of greedy bisimulation. 
Without this middle ground, verifying Theorem 22 would be challenging, especially given that neither the input coalgebras nor their bisimulation are assumed to be finite. 

Finally, we emphasize that our contribution extends beyond bisimulation of coalgebras.
We also presented two methods for generating coalgebras from expressions and proved their correctness, finiteness, and correspondence.

Regarding our experiments, we have revised our tests in our repository. 
We also stress that trivial tests do not provide any performance benefit for algorithms based on Thompson's construction, and dead tests do not favor our algorithm. 
As mentioned before, we have conceptual demonstrations of performance improvements in the submitted version. 

# Reviewer Questions

### Reviewer 1

> Where are the benchmarks from?

It is generated by https://github.com/c-cube/qcheck, based on algebraic rules of GKAT (excluding fixpoint rule) with reflexivity, congruence, and symmetry rules.
We will include the generation script and provide documentation.

> Unnecessary but harmful generalization

We will clarify that the functor `F` satisfies necessary properties.

### Reviewer 2

Our approach diverges from previous works on symbolic transducers in several aspects:
- Our on-the-fly method is tailored for normalization, a unique challenge in achieving finite trace equivalence for GKAT. 
- The signature of GKAT differs from traditional symbolic transducers. Unlike typical accepting or rejecting states, a GKAT state can accept or reject based on different input atoms. This results in a semantics where a trace ends in an atom, representing the output program state.

While symbolic bisimulation is a valuable contribution, it is not our sole contribution. 
We spent most of the paper developing an on-the-fly bisimulation algorithm and two distinct method to construct symbolic GKAT coalgebra from expressions, and proved their desirable properties.

# Detailed Response

### Reviewer 1

> it's unclear to me what section III is for

The correctness result of section IV is based on that of section III. 

### Reviewer 2

> can you say a bit more about SymKAT

SymKAT is a symbolic equivalence checker for KAT; on the other hand, our algorithm focuses on the GKAT fragment.
This specialization allows us to produce smaller coalgebra and utilize efficient SAT solver.
Our comparison demonstrated that GKAT equivalence can be checked more efficiently using our specialized solver.

### Reviewer 3

> Theorem 23 is not the proper tool to justify the correctness of the algorithm

Union-find structures represent equivalence relations. 
By employing union-find instead of a set of pairs, our algorithm searches for a greedy bisimulation that is also an equivalence relation. 
While the correctness of greedy bisimulation is established (Theorem 21), Theorem 23 justifies finding a greedy bisimulation that is also an equivalence relation is correct. 

> p7c2 [...] the liveness analysis would be faster 

Consider two bisimilar states in a GKAT coalgebra with no dead state. 
The classical algorithm would perform a liveness check, iterating through all the states; then proceed with bisimulation, iterating through all the states again. 
Our algorithm simply performs the bisimulation, bypassing the liveness check altogether.







<!-- > p5c2 [...] The first two are the same benefit.

The first benefit stems from the laziness of our liveness checking algorithm, allowing us to iterate through fewer states in the classical algorithm (see overall response and the next comment).  
This benefit is apparent no matter the result or the generation method of the coalgebra. 
The second benefit stems from the on-the-fly nature of our algorithm.
Specifically, our algorithm can terminate without generating the rest of the coalgebra, when a counter-example is encountered while applying an on-the-fly generation method (such as derivatives).
In contrast, the original algorithm requires the complete generation of the coalgebra in order to perform liveness checking first. -->

<!-- 
!!!!!!! NOTES, DO NOT SUBMIT !!!!!!!
1. Practicality of the tool
    - Speed up of normalization 
        - discussion at the end of section III;
        - better sketch of liveness checking.
    - Trivial/Dead Equivalence
2. Comparison with existing work
    - Intuitive, but coalgebraic characterization is novel
    - coalgebraic characterization enables straightforward proofs
    - Theorem 22 is non-trivial because there is no assumption of finiteness
3. additional results besides automata
    - We also presented two ways to generate automata in Section V and proved them correct and equivalent.
    - Automata shape difference, allow acceptation or rejection based on an atom.
3. Tests generation
    - We generate the tests roughly based on the shape of real-world program input 
        - more sequencing than while etc.
    - negative cases are random expression, but they still need to do liveness check
    - We will rework the tests to 
        - reduce the number of trivial and dead tests, 
        - make sure that the random expression do go into dead state detection immediately
4. Writing
    - More about the efficiency of laziness 
-->

